<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script src="./browser.min.js"></script>
	<script>


	//实现一个call函数
	// 将要改变this指向的方法挂到目标this上执行并返回
	// Function.prototype.mycall = function (context) {
	//   if (typeof this !== 'function') {
	//     throw new TypeError('not funciton')
	//   }
	//   context = context || window
	//   context.fn = this
	//   let arg = [...arguments].slice(1)
	//   let result = context.fn(...arg)
	//   delete context.fn
	//   return result
	// } 


// Function.prototype.mybind = function (context) {
//   if (typeof this !== 'function') {
//     throw new TypeError('Error')
//   }
//   let _this = this
//   let arg = [...arguments].slice(1)
//   return function F() {
//     // 处理函数使用new的情况
//     if (this instanceof F) {
//       return new _this(...arg, ...arguments)
//     } else {
//       return _this.apply(context, arg.concat(...arguments))
//     }
//   }
// }


// 右边变量的原型存在于左边变量的原型链上
// function instanceOf(left, right) {
//   let leftValue = left.__proto__
//   let rightValue = right.prototype
//   while (true) {
//     if (leftValue === null) {
//       return false
//     }
//     if (leftValue === rightValue) {
//       return true
//     }
//     leftValue = leftValue.__proto__
//   }
// }



function throttle (fn, delay) {
  // 利用闭包保存时间
  let prev = Date.now()
  return function () {
    let context = this
	let arg = arguments
	console.log(context, arg)
    let now = Date.now()
    if (now - prev >= delay) {
      fn.apply(context, arg)
      prev = Date.now()
    }
  }
}

function fn () {
  console.log('节流')
}
addEventListener('click', throttle(fn, 1000)) 
















	</script>
	
</body>
</html>

同
start

end





4

5

2

